\chapter{Parameter table}\label{app:parameter_tables}
This appendix serves as an overview of the different parameters present in the attack (and defense). 
\centering
\renewcommand*{\arraystretch}{1.7}
\begin{longtable}{p{3cm}p{2.5cm}p{7cm}}
\caption{Parameter table}
\label{tbl:parameter_table}\\
\toprule
Parameter &Default value &Usage \\ \midrule \endfirsthead
\toprule
Parameter &Default value &Usage \\ \midrule \endhead
\bottomrule\endfoot
Number of  particles	&5 &Controls the number of particles in the \gls{pso} swarm. Increasing the number of particles decreases the evasiveness of the algorithm but decreases the efficiency as seen in section \ref{sec:combining_pso_bba}. Decreasing the value decreases both the evasiveness and efficiency.\\
Number of nodes $N$&10 &Controls the number of nodes over which the query submission can be distributed. Increasing the number of nodes helps the algorithm to be more evasive as seen in section \ref{sec:more_nodes}. Every added node comes with a certain cost.\\
Query budget &25000 &Controls the maximum number of queries that can be submitted by the attack. Increasing the number can make the attack more efficient, but the later queries tend to trigger more detections, causing the evasiveness to drop.\\
Group size $s$ &1 &Controls the number of experiments that are grouped and are executed concurrently. The queries of the attacks in the same group are submitted in an interleaved fashion. Increasing this value aids in the evasiveness of the attack without sacrificing efficiency. Experiments have been performed with this parameter in section \ref{sec:noise_insertion}.\\
Distribution scheme &\gls{rr} distribution &Controls how the queries are distributed over the different nodes. As discussed in section \ref{sec:distribution}, the distribution scheme does not heavily influence the number of detections. Other options for this parameter are the \gls{mrr}, \gls{db} and \gls{edb} distribution schemes.\\
History length	&20	&Controls the size of the query submission history that is taken into account in the \gls{db} and \gls{edb} distribution schemes. As seen in section \ref{sec:distance_based_modifications}, increasing this value helps the algorithm remain more evasive at an added computational cost. The chosen value is a middle ground between this computational cost and the evasiveness.\\
Source step $\epsilon$ &0.25 (MNIST) 0.20 (CIFAR) & Controls the step towards the original image in the \gls{bba}. This parameter is also shown in Figure \ref{fig:boundary_attack_intuition} as $\epsilon$. Increasing the value causes the queries to be more spread out over the search space, ultimately lowering detections. However, increasing the value too much will result in slow convergence of the attack.\\
Spherical step $\eta$	&0.05 & Controls the size of the random direction of the \gls{bba} algorithm. This parameter is also shown in Figure \ref{fig:boundary_attack_intuition} as $\eta$. The value of this parameter is chosen based on the results of \cite{brunner_guessing_2019}. Increasing the value adds more randomness to the algorithm, but can hamper convergence.\\
Source step multiplier up &1.05	&Controls the speed at which the source step increases when the new position remains adversarial. Setting this value to 1 (together with the source step multiplier down) fixes the value of the source step for the entire duration of the attack. The increasing value of the source step helps the attack to be more evasive due to the submitted queries being more spread out.\\
Source step multiplier down &0.99 &Controls the speed at which the source step decreases when the new position remains non-adversarial. Setting this value to 1 (together with the source step multiplier up) fixes the value of the source step for the entire duration of the attack. The decreasing value of the source step helps the attack to be more efficient, since the smaller steps aid convergence.\\
Recalculate mask every &50	&Controls after how many iterations the mask used in the \gls{bba} should be recalculated. This parameter has no big effect on the efficiency of the attack, only on the run time. After a sufficient amount of iterations, the masks tend to change only slightly.\\
Particle acceleration coefficient $c_p$ &2\footnote{\label{ftn:cp} Due to the multi-group approach, these values are actually set based on equations \ref{eq:cp_mg} and \ref{eq:cg_mg} with $A1$ and $A2$ being 1 and 2 respectively.} &Controls the rate of attraction towards the personal best position of a particle. The different steps of the particle are weighted according to equation \ref{eq:position_update}. Increasing this value creates a stronger attraction to the personal best position of the particle.\\
Global acceleration coefficient $c_g$ &1\textsuperscript{\ref{ftn:cp}} &Controls the rate of attraction towards the best position of the swarm. The different steps of the particle are weighted according to equation \ref{eq:position_update}. Increasing this value creates a stronger attraction to the best position of the swarm.\\
Maximum velocity $v_{max}$ &0.5 &Controls the maximum velocity of a particle. The velocity values of equation \ref{eq:velocity_update} are clipped by this value in order to avoid the problem of exploding velocities. Decreasing this value causes the algorithm to take smaller steps in every iteration, which in turn reduces the evasiveness.\\
$w_{start}$ &1 &Controls the value of the inertia weight of equation \ref{eq:weight}. Decreasing the value will cause the particle to change its direction more easily at the beginning of the attack, allowing for more exploitation of the search space.\\
$w_{end}$ &0 &Controls the value of the inertia weight of equation \ref{eq:weight}. Increasing the value will cause the particle to change its direction more easily at the end of the attack, allowing for more exploitation of the search space.\\
$\kappa$ &0.8 &Controls the rate of convergence of the \gls{pso} algorithm when using a constriction factor $\chi$. Increasing this value results in slower convergence, but a more thorough search. Decreasing this value has the opposite effect. The value should be between 0 and 1.\\
Insert type &Test data &Controls the type of noise queries that are inserted in order to flush the buffer of the detector. The other options are uniforms noise, Perlin noise with a fixed frequency, Perlin noise with a variable frequency and a mix of all other approaches. Other approaches have a smaller inter query distance as shown in Table \ref{tbl:noise_distances}. Therefore train data noise is the best option in terms of evasiveness.\\
Insert time &Distance based &Controls when noise queries should be inserted to flush the buffer of the detector. Other options are fixed intervals and geometric decay.\\
Insert count &1 &Controls the number of noise queries that are inserted every time the 'Insert time' decides that noise should be inserted. Inserting more noise queries can improve evasiveness, but the efficiency is lowered since fewer queries are used to progress the attack.\\
Insert threshold &/ &Controls the threshold used in the distance-based insertion scheme. Whenever the distance between an impending query and the previously submitted queries falls below this value, noise queries will be inserted. Increasing this value will result in more noise being inserted, causing the evasiveness to increase while the efficiency drops. Increasing the value too high will result in more detections due to the noise queries being flagged as an attack.\\
Insert decay rate &/ &Controls the decay rate of the geometric decay insertion scheme. The number should be smaller than 1 in order to insert more queries near the end of the attack. The closer this number is to zero, the faster the noise queries will be inserted.\\
\end{longtable}

\begin{longtable}{p{3cm}p{2.5cm}p{7cm}}
\caption[Parameter table of the defense]{Parameter table of the defense\protect\footnotemark}
\label{tbl:parameter_table_defense}\\
\toprule
Parameter &Default value &Usage \\ \midrule \endfirsthead
\toprule
Parameter &Default value &Usage \\ \midrule \endhead
\bottomrule\endfoot
\footnotetext{Note that the attacker has no control over (and knowledge of) these parameters. However, the optimal parameters of the attack heavily depend on the defense parameters.}
Buffer type &Query bounded &Controls how queries will be removed from the buffer. A query bounded buffer will hold a certain amount of queries. If a new query has to be added when the capacity is reached then queries are removed based on the first in, first out method \cite{fifo}. The other option is a time-bounded buffer where queries are removed once they reach a certain age. This approach requires more computations as checks need to happen regularly. Therefore the query bounded buffer is chosen in line with \cite{chen_stateful_2019}.\\
Buffer size &1000 &Controls the number of queries the buffer holds before queries are removed again. Increasing the value results in more attacks being possibly flagged but requires more storage. The value is chosen in line with \cite{chen_stateful_2019}.\\
$k$ &50 &Controls the number of neighbors that are considered when computing the average distance to a new incoming query. Increasing the value flags attacks with more certainty. However, this value is also equal to the number of queries that have to be inserted before any attack can be detected. Increasing the value too far will therefore result in no detections. The value is chosen in line with \cite{chen_stateful_2019}.\\
Threshold &0.009 (MNIST) 0.021 (CIFAR) &Controls the threshold used to flag attacks. If the mean distance to the nearest neighbors of an incoming query falls below this value then the query is flagged as an attack in progress. Appropriate action can be taken against the account that submitted this query. The thresholds are determined based on the procedure discussed in \cite{chen_stateful_2019}. A false positive rate of 0.1\% will be achieved when adding all benign queries of the training set of the respective dataset.\\
Flush buffer after detection &True &Controls whether or not the buffer of the detector should be cleared after a detection happens. The value is set to true in order to simulate the user having to set up a new account after the previous account has been banned. If milder actions, such as a temporary ban, are taken then the buffer should not be cleared.\\
Shadow ban &False &Controls whether or not the user is notified of a ban. If the value is false then the user is notified. This seems the most probable setting in real scenarios as there is no straightforward way to shadow ban a user while using an \gls{api}. The attacker can use the knowledge of bans to its advantage as discussed in section \ref{sec:distance_based_modifications}.\\
\end{longtable}